<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Audio Converter</title>
  <style>
    :root {
      --primary: #2563eb;
      --primary-dark: #1d4ed8;
      --bg: #f1f3f7;
      --card-bg: #ffffff;
      --border-radius: 14px;
    }

    * {
      box-sizing: border-box;
    }

    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: var(--bg);
      margin: 0;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 1rem;
    }

    .card {
      background: var(--card-bg);
      width: 100%;
      max-width: 700px;
      border-radius: var(--border-radius);
      box-shadow: 0 10px 30px rgba(15, 23, 42, 0.15);
      padding: 1.75rem;
      display: flex;
      flex-direction: column;
      gap: 1.25rem;
    }

    h1 {
      margin: 0 0 0.4rem 0;
      font-size: 1.3rem;
    }

    .subtitle {
      margin: 0;
      color: #6b7280;
      font-size: 0.9rem;
    }

    label {
      font-weight: 600;
      font-size: 0.85rem;
      display: block;
      margin-bottom: 0.25rem;
    }

    select,
    input[type="number"] {
      width: 100%;
      padding: 0.45rem 0.6rem;
      border-radius: 6px;
      border: 1px solid #d1d5db;
      font-size: 0.9rem;
    }

    .row {
      display: flex;
      gap: 0.75rem;
    }

    .row > div {
      flex: 1;
    }

    .checkbox-row {
      display: flex;
      align-items: center;
      gap: 0.4rem;
      margin-top: 0.25rem;
      font-size: 0.85rem;
    }

    button {
      appearance: none;
      border: none;
      border-radius: 999px;
      padding: 0.6rem 1rem;
      font-size: 0.95rem;
      font-weight: 600;
      cursor: pointer;
      background: var(--primary);
      color: white;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 0.4rem;
      transition: background 0.15s ease, transform 0.05s ease;
    }

    button:hover {
      background: var(--primary-dark);
    }

    button:active {
      transform: translateY(1px);
    }

    button.secondary {
      background: #e5e7eb;
      color: #111827;
    }

    button.secondary:hover {
      background: #d1d5db;
    }

    #convertBtn {
      width: 100%;
      margin-top: 0.5rem;
    }

    #status {
      margin-top: 0.5rem;
      font-size: 0.85rem;
      font-weight: 600;
      color: #111827;
    }

    #error-log {
      margin-top: 0.5rem;
      color: #b91c1c;
      font-family: monospace;
      font-size: 0.75rem;
      white-space: pre-wrap;
      background: #fee2e2;
      border-radius: 8px;
      padding: 0.5rem 0.75rem;
      display: none;
    }

    .drag-zone {
      border-radius: 12px;
      border: 1.5px dashed #cbd5f5;
      background: #eff4ff;
      padding: 1rem;
      text-align: center;
      cursor: pointer;
      transition: border-color 0.15s ease, background 0.15s ease, transform 0.1s ease;
    }

    .drag-zone.dragover {
      border-color: var(--primary);
      background: #e0ebff;
      transform: translateY(-1px);
    }

    .drag-zone-title {
      font-weight: 600;
      margin-bottom: 0.15rem;
    }

    .drag-zone-sub {
      font-size: 0.8rem;
      color: #6b7280;
    }

    #fileInput {
      display: none;
    }

    .file-list {
      max-height: 200px;
      overflow-y: auto;
      border-radius: 8px;
      border: 1px solid #e5e7eb;
      padding: 0.4rem 0.3rem;
      background: #f9fafb;
      font-size: 0.8rem;
    }

    .file-item {
      padding: 0.3rem 0.45rem;
      border-radius: 6px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      cursor: pointer;
      gap: 0.4rem;
    }

    .file-item:hover {
      background: #eef2ff;
    }

    .file-item.active {
      background: #e0ebff;
    }

    .file-name {
      flex: 1;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .file-status {
      font-size: 0.75rem;
      color: #6b7280;
      white-space: nowrap;
    }

    .waveform-container {
      border-radius: 10px;
      border: 1px solid #e5e7eb;
      padding: 0.75rem;
      background: #f9fafb;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    #waveform {
      width: 100%;
      height: 96px;
      cursor: pointer;
    }

    .wave-controls {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 0.5rem;
    }

    .wave-info {
      font-size: 0.78rem;
      color: #6b7280;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    progress {
      width: 100%;
      height: 8px;
      border-radius: 999px;
      overflow: hidden;
      appearance: none;
    }

    progress::-webkit-progress-bar {
      background-color: #e5e7eb;
      border-radius: 999px;
    }

    progress::-webkit-progress-value {
      background-color: var(--primary);
      border-radius: 999px;
    }

    progress::-moz-progress-bar {
      background-color: var(--primary);
      border-radius: 999px;
    }

    .progress-row {
      margin-top: 0.25rem;
    }

    .progress-label {
      font-size: 0.75rem;
      color: #6b7280;
      margin-bottom: 0.1rem;
      display: flex;
      justify-content: space-between;
    }
  </style>
</head>
<body>
  <div class="card">
    <div>
      <h1>Audio Converter</h1>
      <p class="subtitle">Drop in audio files, preview the waveform, trim, and convert to WAV or MP3.</p>
    </div>

    <!-- Drag & Drop (clickable to open file picker) -->
    <div id="dragZone" class="drag-zone">
      <div class="drag-zone-title">Drop audio files here</div>
      <div class="drag-zone-sub">or click to browse</div>
    </div>
    <input type="file" id="fileInput" accept="audio/*" multiple />

    <!-- File list -->
    <div class="file-list" id="fileList"></div>

    <!-- Waveform -->
    <div class="waveform-container">
      <div id="waveform"></div>
      <div class="wave-controls">
        <button id="playPauseBtn" class="secondary" disabled>Play</button>
        <div class="wave-info" id="waveInfo">No file selected.</div>
      </div>
    </div>

    <!-- Options -->
    <div>
      <label>Convert to format</label>
      <select id="formatSelect">
        <option value="mp3">MP3</option>
        <option value="wav">WAV</option>
      </select>
    </div>

    <div class="row">
      <div>
        <label>Trim start (sec)</label>
        <input type="number" id="trimStart" min="0" placeholder="0" />
      </div>
      <div>
        <label>Trim end (sec)</label>
        <input type="number" id="trimEnd" min="0" placeholder="0" />
      </div>
    </div>

    <label class="checkbox-row">
      <input type="checkbox" id="autoTrim" />
      Auto-trim silence at start & end
    </label>

    <button id="convertBtn">Convert all files</button>

    <!-- Progress -->
    <div class="progress-row">
      <div class="progress-label">
        <span>FFmpeg Core</span>
        <span id="ffmpegLoadLabel">Loading…</span>
      </div>
      <progress id="ffmpegProgress" max="100" value="0"></progress>
    </div>

    <div class="progress-row">
      <div class="progress-label">
        <span>Batch progress</span>
        <span id="batchLabel">0 / 0</span>
      </div>
      <progress id="overallProgress" max="100" value="0"></progress>
    </div>

    <div id="status">Initializing FFmpeg…</div>
    <pre id="error-log"></pre>
  </div>

  <!-- WaveSurfer -->
  <script src="./wavesurfer.min.js"></script>
  <!-- Self-hosted ffmpeg wrapper -->
  <script src="./ffmpeg.min.js"></script>

  <script>
    document.addEventListener("DOMContentLoaded", () => {
      const statusEl = document.getElementById("status");
      const errorLogEl = document.getElementById("error-log");
      const dragZone = document.getElementById("dragZone");
      const fileInput = document.getElementById("fileInput");
      const fileListEl = document.getElementById("fileList");
      const formatSelect = document.getElementById("formatSelect");
      const trimStartEl = document.getElementById("trimStart");
      const trimEndEl = document.getElementById("trimEnd");
      const autoTrimEl = document.getElementById("autoTrim");
      const convertBtn = document.getElementById("convertBtn");
      const ffmpegProgressEl = document.getElementById("ffmpegProgress");
      const ffmpegLoadLabelEl = document.getElementById("ffmpegLoadLabel");
      const overallProgressEl = document.getElementById("overallProgress");
      const batchLabelEl = document.getElementById("batchLabel");
      const playPauseBtn = document.getElementById("playPauseBtn");
      const waveInfoEl = document.getElementById("waveInfo");

      let selectedFiles = [];
      let activeIndex = -1;
      let ffmpegLoaded = false;
      let logCapture = null;
      let currentObjectUrl = null;

      // --- WaveSurfer setup ---
      const wavesurfer = WaveSurfer.create({
        container: "#waveform",
        waveColor: "#cbd5f5",
        progressColor: "#2563eb",
        cursorColor: "#2563eb",
        height: 96,
        responsive: true,
      });

      wavesurfer.on("ready", () => {
        playPauseBtn.disabled = false;
      });

      wavesurfer.on("finish", () => {
        playPauseBtn.textContent = "Play";
      });

      playPauseBtn.addEventListener("click", () => {
        if (!wavesurfer) return;
        wavesurfer.playPause();
        playPauseBtn.textContent = wavesurfer.isPlaying() ? "Pause" : "Play";
      });

      function loadWaveformForIndex(index) {
        const file = selectedFiles[index];
        if (!file) return;

        activeIndex = index;
        updateFileListUI();

        if (currentObjectUrl) {
          URL.revokeObjectURL(currentObjectUrl);
        }
        currentObjectUrl = URL.createObjectURL(file);
        wavesurfer.load(currentObjectUrl);
        waveInfoEl.textContent = file.name;
        playPauseBtn.textContent = "Play";
        playPauseBtn.disabled = true;
      }

      // --- FFmpeg setup ---
      const { createFFmpeg, fetchFile } = FFmpeg;
      const corePath = new URL("./ffmpeg-core.js", window.location.href).href;

      const ffmpeg = createFFmpeg({
        log: true,
        mainName: "main",
        corePath,
      });

      ffmpeg.setLogger(({ type, message }) => {
        if (logCapture) {
          logCapture.push(message);
        }
      });

      (async () => {
        try {
          statusEl.textContent = "Loading FFmpeg core…";
          ffmpegProgressEl.value = 10;
          await ffmpeg.load();
          ffmpegLoaded = true;
          ffmpegProgressEl.value = 100;
          ffmpegLoadLabelEl.textContent = "Loaded";
          statusEl.textContent = "FFmpeg ready.";
        } catch (err) {
          ffmpegProgressEl.value = 0;
          ffmpegLoadLabelEl.textContent = "Error";
          statusEl.textContent = "Failed to load FFmpeg.";
          errorLogEl.textContent = String(err);
          errorLogEl.style.display = "block";
        }
      })();

      // --- Add files ---
      function handleFiles(files) {
        const newFiles = Array.from(files).filter(f => f.type.startsWith("audio/") || !f.type);
        if (!newFiles.length) return;

        selectedFiles = selectedFiles.concat(newFiles);
        renderFileList();
        if (activeIndex === -1 && selectedFiles.length > 0) {
          loadWaveformForIndex(0);
        }
        updateBatchProgress(0, selectedFiles.length);
      }

      // Click on drag area → open file dialog
      dragZone.addEventListener("click", () => {
        fileInput.click();
      });

      // Drag & drop behavior
      ["dragenter", "dragover", "dragleave", "drop"].forEach(eventName => {
        dragZone.addEventListener(eventName, e => {
          e.preventDefault();
          e.stopPropagation();
        });
      });

      dragZone.addEventListener("dragover", () => {
        dragZone.classList.add("dragover");
      });

      dragZone.addEventListener("dragleave", () => {
        dragZone.classList.remove("dragover");
      });

      dragZone.addEventListener("drop", e => {
        dragZone.classList.remove("dragover");
        if (e.dataTransfer && e.dataTransfer.files) {
          handleFiles(e.dataTransfer.files);
        }
      });

      // File input change
      fileInput.addEventListener("change", e => {
        if (e.target.files) {
          handleFiles(e.target.files);
        }
        fileInput.value = "";
      });

      // --- File list UI ---
      function renderFileList() {
        fileListEl.innerHTML = "";
        if (!selectedFiles.length) {
          fileListEl.innerHTML = '<div style="padding:0.3rem 0.45rem;color:#9ca3af;">No files selected.</div>';
          return;
        }

        selectedFiles.forEach((file, idx) => {
          const item = document.createElement("div");
          item.className = "file-item" + (idx === activeIndex ? " active" : "");
          item.dataset.index = idx;

          const nameSpan = document.createElement("div");
          nameSpan.className = "file-name";
          nameSpan.textContent = file.name;

          const statusSpan = document.createElement("div");
          statusSpan.className = "file-status";
          statusSpan.id = `fileStatus-${idx}`;
          statusSpan.textContent = "Pending";

          item.appendChild(nameSpan);
          item.appendChild(statusSpan);

          item.addEventListener("click", () => {
            loadWaveformForIndex(idx);
          });

          fileListEl.appendChild(item);
        });
      }

      function updateFileStatus(index, text) {
        const el = document.getElementById(`fileStatus-${index}`);
        if (el) el.textContent = text;
      }

      function updateFileListUI() {
        Array.from(fileListEl.children).forEach(child => {
          if (!child.classList.contains("file-item")) return;
          const idx = Number(child.dataset.index);
          if (idx === activeIndex) {
            child.classList.add("active");
          } else {
            child.classList.remove("active");
          }
        });
      }

      function updateBatchProgress(processed, total) {
        batchLabelEl.textContent = `${processed} / ${total}`;
        overallProgressEl.max = total || 1;
        overallProgressEl.value = processed;
      }

      // --- Duration helper ---
      async function getDurationSeconds(inputName) {
        logCapture = [];
        try {
          await ffmpeg.run("-i", inputName);
        } catch (e) {
          // expected – we only care about logs
        }
        const logs = logCapture.join("\n");
        logCapture = null;

        const match = logs.match(/Duration:\s(\d+):(\d+):(\d+\.\d+)/);
        if (!match) return null;

        const hours = Number(match[1]);
        const mins = Number(match[2]);
        const secs = Number(match[3]);
        return hours * 3600 + mins * 60 + secs;
      }

      // --- Single file conversion ---
      async function convertSingleFile(file, index, options) {
        const { format, trimStart, trimEnd, autoTrim } = options;

        const ext = file.name.includes(".")
          ? file.name.split(".").pop()
          : "audio";
        const baseName = file.name.replace(/\.[^/.]+$/, "");
        const inputName = `input_${index}.${ext}`;
        const outputName = `${baseName}_converted.${format}`;

        updateFileStatus(index, "Writing…");
        ffmpeg.FS("writeFile", inputName, await fetchFile(file));

        let args = [];

        if (trimStart > 0) {
          args.push("-ss", String(trimStart));
        }

        args.push("-i", inputName);

        if (trimEnd > 0) {
          updateFileStatus(index, "Measuring duration…");
          const duration = await getDurationSeconds(inputName);
          if (duration && duration > trimEnd) {
            const newDuration = duration - trimEnd;
            args.push("-t", String(newDuration));
          }
        }

        if (autoTrim) {
          args.push(
            "-af",
            "silenceremove=start_periods=1:start_duration=0.1:start_threshold=-50dB:" +
              "end_periods=1:end_duration=0.1:end_threshold=-50dB"
          );
        }

        if (format === "mp3") {
          args.push("-acodec", "libmp3lame", "-b:a", "192k");
        }

        args.push(outputName);

        updateFileStatus(index, "Converting…");
        await ffmpeg.run(...args);

        updateFileStatus(index, "Reading…");
        const data = ffmpeg.FS("readFile", outputName);
        const blob = new Blob([data.buffer], {
          type: format === "mp3" ? "audio/mpeg" : "audio/wav",
        });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = outputName;
        a.click();
        URL.revokeObjectURL(url);

        updateFileStatus(index, "Done");
      }

      // --- Batch conversion ---
      convertBtn.addEventListener("click", async () => {
        if (!ffmpegLoaded) {
          alert("FFmpeg core is still loading. Please wait a moment and try again.");
          return;
        }
        if (!selectedFiles.length) {
          alert("Please add at least one audio file.");
          return;
        }

        const format = formatSelect.value;
        const trimStart = Number(trimStartEl.value || 0);
        const trimEnd = Number(trimEndEl.value || 0);
        const autoTrim = autoTrimEl.checked;

        statusEl.textContent = "Starting batch conversion…";
        errorLogEl.style.display = "none";
        errorLogEl.textContent = "";

        const total = selectedFiles.length;
        let processed = 0;
        updateBatchProgress(0, total);
        convertBtn.disabled = true;

        for (let i = 0; i < selectedFiles.length; i++) {
          try {
            await convertSingleFile(selectedFiles[i], i, {
              format,
              trimStart,
              trimEnd,
              autoTrim,
            });
            processed++;
            updateBatchProgress(processed, total);
            statusEl.textContent = `Converted ${processed} of ${total}.`;
          } catch (err) {
            updateFileStatus(i, "Error");
            errorLogEl.textContent += `File ${selectedFiles[i].name} error:\n${String(
              err
            )}\n\n`;
            errorLogEl.style.display = "block";
          }
        }

        convertBtn.disabled = false;
        statusEl.textContent = "Batch conversion complete.";
      });
    });
  </script>
</body>
</html>
