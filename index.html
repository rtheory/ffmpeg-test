<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Audio Converter</title>
  <style>
    :root {
      --primary: #2563eb;
      --primary-dark: #1d4ed8;
      --bg: #f1f3f7;
      --card-bg: #ffffff;
      --border-radius: 14px;
    }

    * {
      box-sizing: border-box;
    }

    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: var(--bg);
      margin: 0;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 1rem;
    }

    .card {
      background: var(--card-bg);
      width: 100%;
      max-width: 700px;
      border-radius: var(--border-radius);
      box-shadow: 0 10px 30px rgba(15, 23, 42, 0.15);
      padding: 1.75rem;
      display: flex;
      flex-direction: column;
      gap: 1.25rem;
    }

    h1 {
      margin: 0 0 0.4rem 0;
      font-size: 1.3rem;
    }

    .subtitle {
      margin: 0;
      color: #6b7280;
      font-size: 0.9rem;
    }

    label {
      font-weight: 600;
      font-size: 0.85rem;
      display: block;
      margin-bottom: 0.25rem;
    }

    select,
    input[type="number"] {
      width: 100%;
      padding: 0.45rem 0.6rem;
      border-radius: 6px;
      border: 1px solid #d1d5db;
      font-size: 0.9rem;
    }

    .row {
      display: flex;
      gap: 0.75rem;
    }

    .row > div {
      flex: 1;
    }

    .checkbox-row {
      display: flex;
      align-items: center;
      gap: 0.4rem;
      margin-top: 0.25rem;
      font-size: 0.85rem;
    }

    button {
      appearance: none;
      border: none;
      border-radius: 999px;
      padding: 0.6rem 1rem;
      font-size: 0.95rem;
      font-weight: 600;
      cursor: pointer;
      background: var(--primary);
      color: white;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 0.4rem;
      transition: background 0.15s ease, transform 0.05s ease;
    }

    button:hover {
      background: var(--primary-dark);
    }

    button:active {
      transform: translateY(1px);
    }

    button.secondary {
      background: #e5e7eb;
      color: #111827;
    }

    button.secondary:hover {
      background: #d1d5db;
    }

    #convertBtn {
      width: 100%;
      margin-top: 0.5rem;
    }

    #status {
      margin-top: 0.5rem;
      font-size: 0.85rem;
      font-weight: 600;
      color: #111827;
    }

    #error-log {
      margin-top: 0.5rem;
      color: #b91c1c;
      font-family: monospace;
      font-size: 0.75rem;
      white-space: pre-wrap;
      background: #fee2e2;
      border-radius: 8px;
      padding: 0.5rem 0.75rem;
      display: none;
    }

    .drag-zone {
      border-radius: 12px;
      border: 1.5px dashed #cbd5f5;
      background: #eff4ff;
      padding: 1rem;
      text-align: center;
      cursor: pointer;
      transition: border-color 0.15s ease, background 0.15s ease, transform 0.1s ease;
    }

    .drag-zone.dragover {
      border-color: var(--primary);
      background: #e0ebff;
      transform: translateY(-1px);
    }

    .drag-zone-title {
      font-weight: 600;
      margin-bottom: 0.15rem;
    }

    .drag-zone-sub {
      font-size: 0.8rem;
      color: #6b7280;
    }

    #fileInput {
      display: none;
    }

    .file-list {
      max-height: 200px;
      overflow-y: auto;
      border-radius: 8px;
      border: 1px solid #e5e7eb;
      padding: 0.4rem 0.3rem;
      background: #f9fafb;
      font-size: 0.8rem;
    }

    .file-item {
      padding: 0.3rem 0.45rem;
      border-radius: 6px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      cursor: pointer;
      gap: 0.4rem;
    }

    .file-item:hover {
      background: #eef2ff;
    }

    .file-item.active {
      background: #e0ebff;
    }

    .file-name {
      flex: 1;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .file-status {
      font-size: 0.75rem;
      color: #6b7280;
      white-space: nowrap;
    }

    .waveform-container {
      border-radius: 10px;
      border: 1px solid #e5e7eb;
      padding: 0.75rem;
      background: #f9fafb;
      display: flex;
      flex-direction: column;
      gap: 0.4rem;
    }

    #waveform {
      width: 100%;
      height: 96px;
      cursor: pointer;
    }

    #waveTimeline {
      width: 100%;
      height: 18px;
      font-size: 0.7rem;
      color: #6b7280;
    }

    .wave-controls {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 0.5rem;
    }

    .wave-info {
      font-size: 0.78rem;
      color: #6b7280;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      flex: 1;
    }

    .wave-time {
      font-size: 0.78rem;
      color: #4b5563;
      white-space: nowrap;
    }

    progress {
      width: 100%;
      height: 8px;
      border-radius: 999px;
      overflow: hidden;
      appearance: none;
    }

    progress::-webkit-progress-bar {
      background-color: #e5e7eb;
      border-radius: 999px;
    }

    progress::-webkit-progress-value {
      background-color: var(--primary);
      border-radius: 999px;
    }

    progress::-moz-progress-bar {
      background-color: var(--primary);
      border-radius: 999px;
    }

    .progress-row {
      margin-top: 0.25rem;
    }

    .progress-label {
      font-size: 0.75rem;
      color: #6b7280;
      margin-bottom: 0.1rem;
      display: flex;
      justify-content: space-between;
    }
  </style>
    <style>
      /* Status indicator styles */
      .status-row { margin-top: 0.5rem; display:flex; justify-content:center; }
      .status-indicator { display:flex; align-items:center; gap:0.6rem; }
      .status-icon { width:18px; height:18px; border-radius:50%; position:relative; }
      .status-icon.idle { background:#e5e7eb; }
      .status-icon.working { background:transparent; }
      .status-icon.working::before {
        content: ""; box-sizing:border-box; position:absolute; inset:0; border-radius:50%;
        border:3px solid rgba(37,99,235,0.15); border-top-color: #2563eb; animation:spin 1s linear infinite;
      }
      .status-icon.complete { background:#16a34a; box-shadow:0 0 0 4px rgba(16,185,129,0.08) inset; }
      .status-text { color:#374151; font-weight:600; font-size:0.9rem; }
      @keyframes spin { to { transform: rotate(360deg); } }
    </style>
</head>
<body>
  <div class="card">
    <div>
      <h1>Audio Converter</h1>
      <p class="subtitle">Drop in audio files, preview the waveform, trim, and convert to WAV or MP3.</p>
    </div>

    <!-- Drag & Drop -->
    <div id="dragZone" class="drag-zone">
      <div class="drag-zone-title">Drop audio files here</div>
      <div class="drag-zone-sub">or click to browse</div>
    </div>
    <input type="file" id="fileInput" accept="audio/*" multiple />

    <!-- File list -->
    <div class="file-list" id="fileList"></div>

    <!-- Waveform + timeline + controls -->
    <div class="waveform-container">
      <div id="waveform"></div>
      <div id="waveTimeline"></div>
      <div class="wave-controls">
        <button id="playPauseBtn" class="secondary" disabled>Play</button>
        <div class="wave-info" id="waveInfo">No file selected.</div>
        <div class="wave-time" id="waveTime">00:00 / 00:00</div>
      </div>
    </div>

    <!-- Options -->
    <div>
      <label>Convert to format</label>
      <select id="formatSelect">
        <option value="mp3">MP3</option>
        <option value="wav">WAV</option>
      </select>
    </div>

    <div class="row">
      <div>
        <label>Trim start (sec)</label>
        <input type="number" id="trimStart" min="0" placeholder="0" />
      </div>
      <div>
        <label>Trim end (sec)</label>
        <input type="number" id="trimEnd" min="0" placeholder="0" />
      </div>
    </div>

    <label class="checkbox-row">
      <input type="checkbox" id="autoTrim" />
      Auto-trim silence at start & end
    </label>

    <button id="convertBtn">Convert all files</button>

    <!-- Status indicator (replaces progress bars) -->
    <div class="status-row">
      <div id="statusIndicator" class="status-indicator">
        <div id="statusIcon" class="status-icon idle" aria-hidden="true"></div>
        <div id="statusText" class="status-text">Ready. Add audio files to begin.</div>
      </div>
    </div>

    <!-- textual status removed; use centered status indicator above -->
    <pre id="error-log"></pre>
  </div>

  <!-- WaveSurfer -->
  <script src="./wavesurfer.min.js"></script>
  <script src="./wavesurfer.timeline.min.js"></script>
  <!-- ffmpeg.wasm wrapper -->
  <script src="./ffmpeg.min.js"></script>

  <script>
    document.addEventListener("DOMContentLoaded", () => {
      // textual `#status` removed; statusTextEl displays status now
      const errorLogEl = document.getElementById("error-log");
      const dragZone = document.getElementById("dragZone");
      const fileInput = document.getElementById("fileInput");
      const fileListEl = document.getElementById("fileList");
      const formatSelect = document.getElementById("formatSelect");
      const trimStartEl = document.getElementById("trimStart");
      const trimEndEl = document.getElementById("trimEnd");
      const autoTrimEl = document.getElementById("autoTrim");
      const convertBtn = document.getElementById("convertBtn");
      const statusIndicatorEl = document.getElementById("statusIndicator");
      const statusIconEl = document.getElementById("statusIcon");
      const statusTextEl = document.getElementById("statusText");
      const playPauseBtn = document.getElementById("playPauseBtn");
      const waveInfoEl = document.getElementById("waveInfo");
      const waveTimeEl = document.getElementById("waveTime");

      let selectedFiles = [];
      let activeIndex = -1;
      let currentObjectUrl = null;
      let isConverting = false;

      const corePath = new URL("./ffmpeg-core.js", window.location.href).href;

      // Helper: format seconds → mm:ss
      function formatTime(seconds) {
        if (!Number.isFinite(seconds)) seconds = 0;
        const m = Math.floor(seconds / 60);
        const s = Math.floor(seconds % 60);
        return `${m.toString().padStart(2, "0")}:${s.toString().padStart(2, "0")}`;
      }

      // Status helpers (replace progress bars)
      function setStatusWorking(message, percent) {
        try {
          statusIconEl.className = "status-icon working";
        } catch (e) {}
        if (message) statusTextEl.textContent = message + (percent ? ` (${percent}%)` : "");
      }

      function setStatusIdle(message) {
        try { statusIconEl.className = "status-icon idle"; } catch (e) {}
        statusTextEl.textContent = message || "Ready. Add audio files to begin.";
      }

      function setStatusComplete(message) {
        try { statusIconEl.className = "status-icon complete"; } catch (e) {}
        statusTextEl.textContent = message || "Complete";
      }

      function setStatusError(message) {
        try { statusIconEl.className = "status-icon idle"; } catch (e) {}
        statusTextEl.textContent = message || "Error";
      }

      // --- WaveSurfer setup ---
      const wavesurfer = WaveSurfer.create({
        container: "#waveform",
        waveColor: "#cbd5f5",
        progressColor: "#2563eb",
        cursorColor: "#2563eb",
        height: 96,
        responsive: true,
      });

      if (WaveSurfer.Timeline) {
        wavesurfer.registerPlugin(
          WaveSurfer.Timeline.create({
            container: "#waveTimeline",
            height: 18,
            timeInterval: 1,
            primaryLabelInterval: 5,
            secondaryLabelInterval: 1,
            style: { fontSize: "10px", color: "#6b7280" },
            formatTimeCallback: (sec) => formatTime(sec),
          })
        );
      }

      wavesurfer.on("ready", () => {
        playPauseBtn.disabled = false;
        const duration = wavesurfer.getDuration() || 0;
        waveTimeEl.textContent = `00:00 / ${formatTime(duration)}`;
      });

      wavesurfer.on("timeupdate", (currentTime) => {
        const duration = wavesurfer.getDuration() || 0;
        waveTimeEl.textContent = `${formatTime(currentTime)} / ${formatTime(duration)}`;
      });

      wavesurfer.on("finish", () => {
        playPauseBtn.textContent = "Play";
      });

      playPauseBtn.addEventListener("click", () => {
        if (!wavesurfer) return;
        wavesurfer.playPause();
        playPauseBtn.textContent = wavesurfer.isPlaying() ? "Pause" : "Play";
      });

      function loadWaveformForIndex(index) {
        const file = selectedFiles[index];
        if (!file) return;

        activeIndex = index;
        updateFileListUI();

        if (currentObjectUrl) {
          URL.revokeObjectURL(currentObjectUrl);
        }
        currentObjectUrl = URL.createObjectURL(file);
        wavesurfer.load(currentObjectUrl);
        waveInfoEl.textContent = file.name;
        playPauseBtn.textContent = "Play";
        playPauseBtn.disabled = true;
        waveTimeEl.textContent = "00:00 / 00:00";
      }

      // --- Duration helper via browser Audio (no extra ffmpeg.run) ---
      function getDurationSecondsFromFile(file) {
        return new Promise((resolve) => {
          const url = URL.createObjectURL(file);
          const audio = new Audio();
          audio.preload = "metadata";

          const cleanup = () => {
            URL.revokeObjectURL(url);
            audio.removeAttribute("src");
            audio.load();
          };

          audio.addEventListener("loadedmetadata", () => {
            const duration = audio.duration;
            cleanup();
            if (!Number.isFinite(duration) || duration <= 0) {
              resolve(null);
            } else {
              resolve(duration);
            }
          });

          audio.addEventListener("error", () => {
            cleanup();
            resolve(null);
          });

          audio.src = url;
        });
      }

      // --- File selection / drag-drop ---
      function handleFiles(files) {
        const newFiles = Array.from(files).filter(f => f.type.startsWith("audio/") || !f.type);
        if (!newFiles.length) return;

        selectedFiles = selectedFiles.concat(newFiles);
        renderFileList();
        if (activeIndex === -1 && selectedFiles.length > 0) {
          loadWaveformForIndex(0);
        }
        updateBatchProgress(0, selectedFiles.length);
      }

      dragZone.addEventListener("click", () => fileInput.click());

      ["dragenter", "dragover", "dragleave", "drop"].forEach(eventName => {
        dragZone.addEventListener(eventName, e => {
          e.preventDefault();
          e.stopPropagation();
        });
      });

      dragZone.addEventListener("dragover", () => dragZone.classList.add("dragover"));
      dragZone.addEventListener("dragleave", () => dragZone.classList.remove("dragover"));

      dragZone.addEventListener("drop", e => {
        dragZone.classList.remove("dragover");
        if (e.dataTransfer && e.dataTransfer.files) {
          handleFiles(e.dataTransfer.files);
        }
      });

      fileInput.addEventListener("change", e => {
        if (e.target.files) {
          handleFiles(e.target.files);
        }
        fileInput.value = "";
      });

      // --- File list UI ---
      function renderFileList() {
        fileListEl.innerHTML = "";
        if (!selectedFiles.length) {
          fileListEl.innerHTML = '<div style="padding:0.3rem 0.45rem;color:#9ca3af;">No files selected.</div>';
          return;
        }

        selectedFiles.forEach((file, idx) => {
          const item = document.createElement("div");
          item.className = "file-item" + (idx === activeIndex ? " active" : "");
          item.dataset.index = idx;

          const nameSpan = document.createElement("div");
          nameSpan.className = "file-name";
          nameSpan.textContent = file.name;

          const statusSpan = document.createElement("div");
          statusSpan.className = "file-status";
          statusSpan.id = `fileStatus-${idx}`;
          statusSpan.textContent = "Pending";

          // Delete button for removing uploaded file
          const delBtn = document.createElement("button");
          delBtn.className = "secondary";
          delBtn.style.padding = "0.2rem 0.45rem";
          delBtn.style.fontSize = "0.75rem";
          delBtn.textContent = "Delete";
          delBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            removeFileAt(idx);
          });

          item.appendChild(nameSpan);
          item.appendChild(statusSpan);
          item.appendChild(delBtn);

          item.addEventListener("click", () => loadWaveformForIndex(idx));

          fileListEl.appendChild(item);
        });
      }

      // Remove a file from the selectedFiles list and update UI/state
      function removeFileAt(index) {
        if (index < 0 || index >= selectedFiles.length) return;
        // Remove the file
        selectedFiles.splice(index, 1);

        // Stop playback and adjust activeIndex and waveform
        try { wavesurfer.stop(); } catch (e) {}

        if (currentObjectUrl) {
          try { URL.revokeObjectURL(currentObjectUrl); } catch (e) {}
          currentObjectUrl = null;
        }

        if (selectedFiles.length === 0) {
          activeIndex = -1;
          try { wavesurfer.empty(); } catch (e) {}
          waveInfoEl.textContent = "No file selected.";
          waveTimeEl.textContent = "00:00 / 00:00";
          playPauseBtn.disabled = true;
          playPauseBtn.textContent = "Play";
        } else {
          // If we removed the currently active file, load the next sensible one
          if (index === activeIndex) {
            const newIndex = Math.min(index, selectedFiles.length - 1);
            loadWaveformForIndex(newIndex);
          } else if (index < activeIndex) {
            // Shift active index down if an earlier file was removed
            activeIndex = Math.max(0, activeIndex - 1);
            updateFileListUI();
          } else {
            updateFileListUI();
          }
        }

        renderFileList();
        updateBatchProgress(0, selectedFiles.length);
      }

      function updateFileStatus(index, text) {
        const el = document.getElementById(`fileStatus-${index}`);
        if (el) el.textContent = text;
      }

      function updateFileListUI() {
        Array.from(fileListEl.children).forEach(child => {
          if (!child.classList.contains("file-item")) return;
          const idx = Number(child.dataset.index);
          if (idx === activeIndex) child.classList.add("active");
          else child.classList.remove("active");
        });
      }

      function updateBatchProgress(processed, total) {
        // Only show converting state when actual work has started (processed > 0).
        // When files are merely queued (processed === 0), show an idle queued state.
        if (!total || total <= 0) {
          setStatusIdle();
          return;
        }
        if (processed === 0) {
          setStatusIdle(`${total} file${total>1?"s":""} queued`);
          return;
        }
        if (processed >= total) {
          setStatusComplete(`Batch complete — ${total} file${total>1?"s":""}`);
        } else {
          setStatusWorking(`Converting ${processed} / ${total}`);
        }
      }

      // --- Single file conversion (new ffmpeg instance per file) ---
      async function convertSingleFile(file, index, options) {
        const { format, trimStart, trimEnd, autoTrim } = options;
        const { createFFmpeg, fetchFile } = FFmpeg;

        const ext = file.name.includes(".")
          ? file.name.split(".").pop()
          : "audio";
        const baseName = file.name.replace(/\.[^/.]+$/, "");
        const inputName = `input_${index}.${ext}`;
        const outputName = `${baseName}_converted.${format}`;

        setStatusWorking("Loading…", 10);

        // New ffmpeg instance for THIS file. Capture logs for silencedetect parsing.
        const logLines = [];
        const ffmpeg = createFFmpeg({
          log: true,
          mainName: "main",
          corePath,
          logger: ({ type, message }) => {
            if (message) logLines.push(String(message));
          },
        });

        // Helper wrapper for this instance
        async function runFFmpegSafe(...args) {
          try {
            return await ffmpeg.run(...args);
          } catch (err) {
            if (err && err.name === "ExitStatus" && (err.status === 0 || err.status === "0")) {
              console.warn("FFmpeg exited with status 0 but threw ExitStatus – treating as success.", err);
              return;
            }
            throw err;
          }
        }

        try {
          updateFileStatus(index, "Loading core…");
          await ffmpeg.load();
          setStatusWorking("Core loaded", 40);

          // Clean up previous runs in this instance (should be none, but safe)
          try { ffmpeg.FS("unlink", inputName); } catch (e) {}
          try { ffmpeg.FS("unlink", outputName); } catch (e) {}

          updateFileStatus(index, "Writing…");
          ffmpeg.FS("writeFile", inputName, await fetchFile(file));
          setStatusWorking("Writing…", 60);

          let args = ["-y"];

          // Determine duration if needed (manual trimEnd or autoTrim detection)
          let duration = null;
          if (trimEnd > 0 || autoTrim) {
            updateFileStatus(index, "Measuring duration…");
            duration = await getDurationSecondsFromFile(file);
          }

          // If autoTrim is requested, run silencedetect to find leading/trailing silence
          let autoTrimStart = null;
          let autoTrimEnd = null;
          if (autoTrim) {
            updateFileStatus(index, "Detecting silence…");
            // Run silencedetect to collect silence_start / silence_end messages
            try {
              // clear any previous logs
              logLines.length = 0;
              await runFFmpegSafe("-i", inputName, "-af", "silencedetect=n=-50dB:d=0.1", "-f", "null", "-");

              const silenceStarts = [];
              const silenceEnds = [];
              for (const line of logLines) {
                const mStart = line.match(/silence_start: ([0-9.]+)/);
                if (mStart) silenceStarts.push(Number(mStart[1]));
                const mEnd = line.match(/silence_end: ([0-9.]+)/);
                if (mEnd) silenceEnds.push(Number(mEnd[1]));
              }

              // Leading silence: use first silence_end if present
              if (silenceEnds.length > 0) {
                autoTrimStart = silenceEnds[0];
              }

              // Trailing silence: use last silence_start if present and we know duration
              if (silenceStarts.length > 0 && duration) {
                const lastStart = silenceStarts[silenceStarts.length - 1];
                if (lastStart > 0 && duration > lastStart) {
                  autoTrimEnd = Math.max(0, duration - lastStart);
                }
              }
            } catch (e) {
              // If silencedetect run fails for any reason, continue without autoTrim
              console.warn("silencedetect failed, skipping auto trim:", e);
            }
          }

          // Apply start trim: prioritize explicit user-provided `trimStart` if >0,
          // otherwise use detected `autoTrimStart` when available.
          const effectiveTrimStart = (trimStart > 0) ? trimStart : (autoTrimStart || 0);
          if (effectiveTrimStart > 0) {
            args.push("-ss", String(effectiveTrimStart));
          }

          args.push("-i", inputName);

          // Apply end trim: prioritize explicit `trimEnd` if provided, otherwise use detected autoTrimEnd
          let effectiveDuration = null;
          if (trimEnd > 0 && duration && duration > trimEnd) {
            effectiveDuration = duration - trimEnd;
          } else if (autoTrimEnd != null && duration && duration > autoTrimEnd) {
            effectiveDuration = duration - autoTrimEnd;
          }
          if (effectiveDuration != null) {
            args.push("-t", String(effectiveDuration));
          }

          if (format === "mp3") {
            args.push("-acodec", "libmp3lame", "-b:a", "192k");
          }

          args.push(outputName);

          updateFileStatus(index, "Converting…");
          setStatusWorking("Converting…", 80);
          await runFFmpegSafe(...args);

          updateFileStatus(index, "Reading…");
          const data = ffmpeg.FS("readFile", outputName);
          setStatusWorking("Reading…", 90);

          // If FFmpeg produced no data (possible when silence-trim removed all audio
          // or an internal error occurred), avoid creating a 0-byte download and
          // surface a helpful error message instead.
          if (!data || data.length === 0) {
            throw new Error("FFmpeg produced an empty output file. The file may have been fully trimmed or conversion failed.");
          }

          // Create Blob directly from the Uint8Array returned by FFmpeg.FS
          const blob = new Blob([data], {
            type: format === "mp3" ? "audio/mpeg" : "audio/wav",
          });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = outputName;
          a.click();
          URL.revokeObjectURL(url);

          setStatusComplete("Done");
          updateFileStatus(index, "Done");
        } catch (err) {
          console.error("FFmpeg error for file", file.name, err);
          updateFileStatus(index, "Error");
          errorLogEl.textContent += `File ${file.name} error:\n${
            err?.message || err?.toString() || String(err)
          }\n\n`;
          errorLogEl.style.display = "block";
          throw err;
        } finally {
          try { ffmpeg.FS("unlink", inputName); } catch (e) {}
          try { ffmpeg.FS("unlink", outputName); } catch (e) {}
          try { ffmpeg.exit && ffmpeg.exit(); } catch (e) {}
          setStatusIdle();
        }
      }

      // --- Batch conversion ---
      convertBtn.addEventListener("click", async () => {
        if (isConverting) {
          alert("Conversion is already running.");
          return;
        }
        if (!selectedFiles.length) {
          alert("Please add at least one audio file.");
          return;
        }

        const format = formatSelect.value;
        const trimStart = Number(trimStartEl.value || 0);
        const trimEnd = Number(trimEndEl.value || 0);
        const autoTrim = autoTrimEl.checked;

        setStatusWorking("Starting batch conversion…");
        errorLogEl.style.display = "none";
        errorLogEl.textContent = "";

        const total = selectedFiles.length;
        let processed = 0;
        updateBatchProgress(0, total);

        convertBtn.disabled = true;
        isConverting = true;

        try {
          for (let i = 0; i < selectedFiles.length; i++) {
            try {
              await convertSingleFile(selectedFiles[i], i, {
                format,
                trimStart,
                trimEnd,
                autoTrim,
              });
              processed++;
              updateBatchProgress(processed, total);
              setStatusWorking(`Converted ${processed} of ${total}.`);
            } catch (err) {
              // per-file error already logged; continue to next file
            }
          }

          setStatusComplete("Batch conversion complete.");
        } finally {
          convertBtn.disabled = false;
          isConverting = false;
        }
      });
    });
  </script>
</body>
</html>
