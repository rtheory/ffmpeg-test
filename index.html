<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Audio Converter</title>
  <style>
    :root {
      --primary: #2563eb;
      --primary-dark: #1d4ed8;
      --bg: #f1f3f7;
      --card-bg: #ffffff;
      --border-radius: 14px;
    }

    * {
      box-sizing: border-box;
    }

    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: var(--bg);
      margin: 0;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 1rem;
    }

    .card {
      background: var(--card-bg);
      width: 100%;
      max-width: 700px;
      border-radius: var(--border-radius);
      box-shadow: 0 10px 30px rgba(15, 23, 42, 0.15);
      padding: 1.75rem;
      display: flex;
      flex-direction: column;
      gap: 1.25rem;
    }

    h1 {
      margin: 0 0 0.4rem 0;
      font-size: 1.3rem;
    }

    .subtitle {
      margin: 0;
      color: #6b7280;
      font-size: 0.9rem;
    }

    label {
      font-weight: 600;
      font-size: 0.85rem;
      display: block;
      margin-bottom: 0.25rem;
    }

    select,
    input[type="number"] {
      width: 100%;
      padding: 0.45rem 0.6rem;
      border-radius: 6px;
      border: 1px solid #d1d5db;
      font-size: 0.9rem;
    }

    .row {
      display: flex;
      gap: 0.75rem;
    }

    .row > div {
      flex: 1;
    }

    .checkbox-row {
      display: flex;
      align-items: center;
      gap: 0.4rem;
      margin-top: 0.25rem;
      font-size: 0.85rem;
    }

    button {
      appearance: none;
      border: none;
      border-radius: 999px;
      padding: 0.6rem 1rem;
      font-size: 0.95rem;
      font-weight: 600;
      cursor: pointer;
      background: var(--primary);
      color: white;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 0.4rem;
      transition: background 0.15s ease, transform 0.05s ease;
    }

    button:hover {
      background: var(--primary-dark);
    }

    button:active {
      transform: translateY(1px);
    }

    button.secondary {
      background: #e5e7eb;
      color: #111827;
    }

    button.secondary:hover {
      background: #d1d5db;
    }

    #convertBtn {
      width: 100%;
      margin-top: 0.5rem;
    }

    #status {
      margin-top: 0.5rem;
      font-size: 0.85rem;
      font-weight: 600;
      color: #111827;
    }

    #error-log {
      margin-top: 0.5rem;
      color: #b91c1c;
      font-family: monospace;
      font-size: 0.75rem;
      white-space: pre-wrap;
      background: #fee2e2;
      border-radius: 8px;
      padding: 0.5rem 0.75rem;
      display: none;
    }

    .drag-zone {
      border-radius: 12px;
      border: 1.5px dashed #cbd5f5;
      background: #eff4ff;
      padding: 1rem;
      text-align: center;
      cursor: pointer;
      transition: border-color 0.15s ease, background 0.15s ease, transform 0.1s ease;
    }

    .drag-zone.dragover {
      border-color: var(--primary);
      background: #e0ebff;
      transform: translateY(-1px);
    }

    .drag-zone-title {
      font-weight: 600;
      margin-bottom: 0.15rem;
    }

    .drag-zone-sub {
      font-size: 0.8rem;
      color: #6b7280;
    }

    #fileInput {
      display: none;
    }

    .file-list {
      max-height: 200px;
      overflow-y: auto;
      border-radius: 8px;
      border: 1px solid #e5e7eb;
      padding: 0.4rem 0.3rem;
      background: #f9fafb;
      font-size: 0.8rem;
    }

    .file-item {
      padding: 0.3rem 0.45rem;
      border-radius: 6px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      cursor: pointer;
      gap: 0.4rem;
    }

    .file-item:hover {
      background: #eef2ff;
    }

    .file-item.active {
      background: #e0ebff;
    }

    .file-name {
      flex: 1;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .file-status {
      font-size: 0.75rem;
      color: #6b7280;
      white-space: nowrap;
    }

    .waveform-container {
      border-radius: 10px;
      border: 1px solid #e5e7eb;
      padding: 0.75rem;
      background: #f9fafb;
      display: flex;
      flex-direction: column;
      gap: 0.4rem;
    }

    #waveform {
      width: 100%;
      height: 96px;
      cursor: pointer;
    }

    #waveTimeline {
      width: 100%;
      height: 18px;
      font-size: 0.7rem;
      color: #6b7280;
    }

    .wave-controls {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 0.5rem;
    }

    .wave-info {
      font-size: 0.78rem;
      color: #6b7280;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      flex: 1;
    }

    .wave-time {
      font-size: 0.78rem;
      color: #4b5563;
      white-space: nowrap;
    }

    progress {
      width: 100%;
      height: 8px;
      border-radius: 999px;
      overflow: hidden;
      appearance: none;
    }

    progress::-webkit-progress-bar {
      background-color: #e5e7eb;
      border-radius: 999px;
    }

    progress::-webkit-progress-value {
      background-color: var(--primary);
      border-radius: 999px;
    }

    progress::-moz-progress-bar {
      background-color: var(--primary);
      border-radius: 999px;
    }

    .progress-row {
      margin-top: 0.25rem;
    }

    .progress-label {
      font-size: 0.75rem;
      color: #6b7280;
      margin-bottom: 0.1rem;
      display: flex;
      justify-content: space-between;
    }
  </style>
</head>
<body>
  <div class="card">
    <div>
      <h1>Audio Converter</h1>
      <p class="subtitle">Drop in audio files, preview the waveform, trim, and convert to WAV or MP3.</p>
    </div>

    <!-- Drag & Drop -->
    <div id="dragZone" class="drag-zone">
      <div class="drag-zone-title">Drop audio files here</div>
      <div class="drag-zone-sub">or click to browse</div>
    </div>
    <input type="file" id="fileInput" accept="audio/*" multiple />

    <!-- File list -->
    <div class="file-list" id="fileList"></div>

    <!-- Waveform + timeline + controls -->
    <div class="waveform-container">
      <div id="waveform"></div>
      <div id="waveTimeline"></div>
      <div class="wave-controls">
        <button id="playPauseBtn" class="secondary" disabled>Play</button>
        <div class="wave-info" id="waveInfo">No file selected.</div>
        <div class="wave-time" id="waveTime">00:00 / 00:00</div>
      </div>
    </div>

    <!-- Options -->
    <div>
      <label>Convert to format</label>
      <select id="formatSelect">
        <option value="mp3">MP3</option>
        <option value="wav">WAV</option>
      </select>
    </div>

    <div class="row">
      <div>
        <label>Trim start (sec)</label>
        <input type="number" id="trimStart" min="0" placeholder="0" />
      </div>
      <div>
        <label>Trim end (sec)</label>
        <input type="number" id="trimEnd" min="0" placeholder="0" />
      </div>
    </div>

    <label class="checkbox-row">
      <input type="checkbox" id="autoTrim" />
      Auto-trim silence at start & end
    </label>

    <button id="convertBtn">Convert all files</button>

    <!-- Progress -->
    <div class="progress-row">
      <div class="progress-label">
        <span>FFmpeg Core</span>
        <span id="ffmpegLoadLabel">Idle</span>
      </div>
      <progress id="ffmpegProgress" max="100" value="0"></progress>
    </div>

    <div class="progress-row">
      <div class="progress-label">
        <span>Batch progress</span>
        <span id="batchLabel">0 / 0</span>
      </div>
      <progress id="overallProgress" max="100" value="0"></progress>
    </div>

    <div id="status">Ready. Add audio files to begin.</div>
    <pre id="error-log"></pre>
  </div>

  <!-- WaveSurfer -->
  <script src="./wavesurfer.min.js"></script>
  <script src="./wavesurfer.timeline.min.js"></script>
  <!-- ffmpeg.wasm wrapper -->
  <script src="./ffmpeg.min.js"></script>

  <script>
    document.addEventListener("DOMContentLoaded", () => {
      const statusEl = document.getElementById("status");
      const errorLogEl = document.getElementById("error-log");
      const dragZone = document.getElementById("dragZone");
      const fileInput = document.getElementById("fileInput");
      const fileListEl = document.getElementById("fileList");
      const formatSelect = document.getElementById("formatSelect");
      const trimStartEl = document.getElementById("trimStart");
      const trimEndEl = document.getElementById("trimEnd");
      const autoTrimEl = document.getElementById("autoTrim");
      const convertBtn = document.getElementById("convertBtn");
      const ffmpegProgressEl = document.getElementById("ffmpegProgress");
      const ffmpegLoadLabelEl = document.getElementById("ffmpegLoadLabel");
      const overallProgressEl = document.getElementById("overallProgress");
      const batchLabelEl = document.getElementById("batchLabel");
      const playPauseBtn = document.getElementById("playPauseBtn");
      const waveInfoEl = document.getElementById("waveInfo");
      const waveTimeEl = document.getElementById("waveTime");

      let selectedFiles = [];
      let activeIndex = -1;
      let currentObjectUrl = null;
      let isConverting = false;

      const corePath = new URL("./ffmpeg-core.js", window.location.href).href;

      // Helper: format seconds → mm:ss
      function formatTime(seconds) {
        if (!Number.isFinite(seconds)) seconds = 0;
        const m = Math.floor(seconds / 60);
        const s = Math.floor(seconds % 60);
        return `${m.toString().padStart(2, "0")}:${s.toString().padStart(2, "0")}`;
      }

      // --- WaveSurfer setup ---
      const wavesurfer = WaveSurfer.create({
        container: "#waveform",
        waveColor: "#cbd5f5",
        progressColor: "#2563eb",
        cursorColor: "#2563eb",
        height: 96,
        responsive: true,
      });

      if (WaveSurfer.Timeline) {
        wavesurfer.registerPlugin(
          WaveSurfer.Timeline.create({
            container: "#waveTimeline",
            height: 18,
            timeInterval: 1,
            primaryLabelInterval: 5,
            secondaryLabelInterval: 1,
            style: { fontSize: "10px", color: "#6b7280" },
            formatTimeCallback: (sec) => formatTime(sec),
          })
        );
      }

      wavesurfer.on("ready", () => {
        playPauseBtn.disabled = false;
        const duration = wavesurfer.getDuration() || 0;
        waveTimeEl.textContent = `00:00 / ${formatTime(duration)}`;
      });

      wavesurfer.on("timeupdate", (currentTime) => {
        const duration = wavesurfer.getDuration() || 0;
        waveTimeEl.textContent = `${formatTime(currentTime)} / ${formatTime(duration)}`;
      });

      wavesurfer.on("finish", () => {
        playPauseBtn.textContent = "Play";
      });

      playPauseBtn.addEventListener("click", () => {
        if (!wavesurfer) return;
        wavesurfer.playPause();
        playPauseBtn.textContent = wavesurfer.isPlaying() ? "Pause" : "Play";
      });

      function loadWaveformForIndex(index) {
        const file = selectedFiles[index];
        if (!file) return;

        activeIndex = index;
        updateFileListUI();

        if (currentObjectUrl) {
          URL.revokeObjectURL(currentObjectUrl);
        }
        currentObjectUrl = URL.createObjectURL(file);
        wavesurfer.load(currentObjectUrl);
        waveInfoEl.textContent = file.name;
        playPauseBtn.textContent = "Play";
        playPauseBtn.disabled = true;
        waveTimeEl.textContent = "00:00 / 00:00";
      }

      // --- Duration helper via browser Audio (no extra ffmpeg.run) ---
      function getDurationSecondsFromFile(file) {
        return new Promise((resolve) => {
          const url = URL.createObjectURL(file);
          const audio = new Audio();
          audio.preload = "metadata";

          const cleanup = () => {
            URL.revokeObjectURL(url);
            audio.removeAttribute("src");
            audio.load();
          };

          audio.addEventListener("loadedmetadata", () => {
            const duration = audio.duration;
            cleanup();
            if (!Number.isFinite(duration) || duration <= 0) {
              resolve(null);
            } else {
              resolve(duration);
            }
          });

          audio.addEventListener("error", () => {
            cleanup();
            resolve(null);
          });

          audio.src = url;
        });
      }

      // --- File selection / drag-drop ---
      function handleFiles(files) {
        const newFiles = Array.from(files).filter(f => f.type.startsWith("audio/") || !f.type);
        if (!newFiles.length) return;

        selectedFiles = selectedFiles.concat(newFiles);
        renderFileList();
        if (activeIndex === -1 && selectedFiles.length > 0) {
          loadWaveformForIndex(0);
        }
        updateBatchProgress(0, selectedFiles.length);
      }

      dragZone.addEventListener("click", () => fileInput.click());

      ["dragenter", "dragover", "dragleave", "drop"].forEach(eventName => {
        dragZone.addEventListener(eventName, e => {
          e.preventDefault();
          e.stopPropagation();
        });
      });

      dragZone.addEventListener("dragover", () => dragZone.classList.add("dragover"));
      dragZone.addEventListener("dragleave", () => dragZone.classList.remove("dragover"));

      dragZone.addEventListener("drop", e => {
        dragZone.classList.remove("dragover");
        if (e.dataTransfer && e.dataTransfer.files) {
          handleFiles(e.dataTransfer.files);
        }
      });

      fileInput.addEventListener("change", e => {
        if (e.target.files) {
          handleFiles(e.target.files);
        }
        fileInput.value = "";
      });

      // --- File list UI ---
      function renderFileList() {
        fileListEl.innerHTML = "";
        if (!selectedFiles.length) {
          fileListEl.innerHTML = '<div style="padding:0.3rem 0.45rem;color:#9ca3af;">No files selected.</div>';
          return;
        }

        selectedFiles.forEach((file, idx) => {
          const item = document.createElement("div");
          item.className = "file-item" + (idx === activeIndex ? " active" : "");
          item.dataset.index = idx;

          const nameSpan = document.createElement("div");
          nameSpan.className = "file-name";
          nameSpan.textContent = file.name;

          const statusSpan = document.createElement("div");
          statusSpan.className = "file-status";
          statusSpan.id = `fileStatus-${idx}`;
          statusSpan.textContent = "Pending";

          item.appendChild(nameSpan);
          item.appendChild(statusSpan);

          item.addEventListener("click", () => loadWaveformForIndex(idx));

          fileListEl.appendChild(item);
        });
      }

      function updateFileStatus(index, text) {
        const el = document.getElementById(`fileStatus-${index}`);
        if (el) el.textContent = text;
      }

      function updateFileListUI() {
        Array.from(fileListEl.children).forEach(child => {
          if (!child.classList.contains("file-item")) return;
          const idx = Number(child.dataset.index);
          if (idx === activeIndex) child.classList.add("active");
          else child.classList.remove("active");
        });
      }

      function updateBatchProgress(processed, total) {
        batchLabelEl.textContent = `${processed} / ${total}`;
        overallProgressEl.max = total || 1;
        overallProgressEl.value = processed;
      }

      // --- Single file conversion (new ffmpeg instance per file) ---
      async function convertSingleFile(file, index, options) {
        const { format, trimStart, trimEnd, autoTrim } = options;
        const { createFFmpeg, fetchFile } = FFmpeg;

        const ext = file.name.includes(".")
          ? file.name.split(".").pop()
          : "audio";
        const baseName = file.name.replace(/\.[^/.]+$/, "");
        const inputName = `input_${index}.${ext}`;
        const outputName = `${baseName}_converted.${format}`;

        ffmpegLoadLabelEl.textContent = "Loading…";
        ffmpegProgressEl.value = 10;

        // New ffmpeg instance for THIS file
        const ffmpeg = createFFmpeg({
          log: false,
          mainName: "main",
          corePath,
        });

        // Helper wrapper for this instance
        async function runFFmpegSafe(...args) {
          try {
            return await ffmpeg.run(...args);
          } catch (err) {
            if (err && err.name === "ExitStatus" && (err.status === 0 || err.status === "0")) {
              console.warn("FFmpeg exited with status 0 but threw ExitStatus – treating as success.", err);
              return;
            }
            throw err;
          }
        }

        try {
          updateFileStatus(index, "Loading core…");
          await ffmpeg.load();
          ffmpegProgressEl.value = 40;
          ffmpegLoadLabelEl.textContent = "Core loaded";

          // Clean up previous runs in this instance (should be none, but safe)
          try { ffmpeg.FS("unlink", inputName); } catch (e) {}
          try { ffmpeg.FS("unlink", outputName); } catch (e) {}

          updateFileStatus(index, "Writing…");
          ffmpeg.FS("writeFile", inputName, await fetchFile(file));
          ffmpegProgressEl.value = 60;

          let args = ["-y"]; // overwrite output

          if (trimStart > 0) {
            args.push("-ss", String(trimStart));
          }

          args.push("-i", inputName);

          if (trimEnd > 0) {
            updateFileStatus(index, "Measuring duration…");
            const duration = await getDurationSecondsFromFile(file);
            if (duration && duration > trimEnd) {
              const newDuration = duration - trimEnd;
              args.push("-t", String(newDuration));
            }
          }

          if (autoTrim) {
            args.push(
              "-af",
              "silenceremove=start_periods=1:start_duration=0.1:start_threshold=-50dB:" +
              "end_periods=1:end_duration=0.1:end_threshold=-50dB"
            );
          }

          if (format === "mp3") {
            args.push("-acodec", "libmp3lame", "-b:a", "192k");
          }

          args.push(outputName);

          updateFileStatus(index, "Converting…");
          ffmpegProgressEl.value = 80;
          await runFFmpegSafe(...args);

          updateFileStatus(index, "Reading…");
          const data = ffmpeg.FS("readFile", outputName);
          ffmpegProgressEl.value = 90;

          // If FFmpeg produced no data (possible when silence-trim removed all audio
          // or an internal error occurred), avoid creating a 0-byte download and
          // surface a helpful error message instead.
          if (!data || data.length === 0) {
            throw new Error("FFmpeg produced an empty output file. The file may have been fully trimmed or conversion failed.");
          }

          // Create Blob directly from the Uint8Array returned by FFmpeg.FS
          const blob = new Blob([data], {
            type: format === "mp3" ? "audio/mpeg" : "audio/wav",
          });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = outputName;
          a.click();
          URL.revokeObjectURL(url);

          ffmpegProgressEl.value = 100;
          updateFileStatus(index, "Done");
        } catch (err) {
          console.error("FFmpeg error for file", file.name, err);
          updateFileStatus(index, "Error");
          errorLogEl.textContent += `File ${file.name} error:\n${
            err?.message || err?.toString() || String(err)
          }\n\n`;
          errorLogEl.style.display = "block";
          throw err;
        } finally {
          try { ffmpeg.FS("unlink", inputName); } catch (e) {}
          try { ffmpeg.FS("unlink", outputName); } catch (e) {}
          try { ffmpeg.exit && ffmpeg.exit(); } catch (e) {}
          ffmpegLoadLabelEl.textContent = "Idle";
          ffmpegProgressEl.value = 0;
        }
      }

      // --- Batch conversion ---
      convertBtn.addEventListener("click", async () => {
        if (isConverting) {
          alert("Conversion is already running.");
          return;
        }
        if (!selectedFiles.length) {
          alert("Please add at least one audio file.");
          return;
        }

        const format = formatSelect.value;
        const trimStart = Number(trimStartEl.value || 0);
        const trimEnd = Number(trimEndEl.value || 0);
        const autoTrim = autoTrimEl.checked;

        statusEl.textContent = "Starting batch conversion…";
        errorLogEl.style.display = "none";
        errorLogEl.textContent = "";

        const total = selectedFiles.length;
        let processed = 0;
        updateBatchProgress(0, total);

        convertBtn.disabled = true;
        isConverting = true;

        try {
          for (let i = 0; i < selectedFiles.length; i++) {
            try {
              await convertSingleFile(selectedFiles[i], i, {
                format,
                trimStart,
                trimEnd,
                autoTrim,
              });
              processed++;
              updateBatchProgress(processed, total);
              statusEl.textContent = `Converted ${processed} of ${total}.`;
            } catch (err) {
              // per-file error already logged; continue to next file
            }
          }

          statusEl.textContent = "Batch conversion complete.";
        } finally {
          convertBtn.disabled = false;
          isConverting = false;
        }
      });
    });
  </script>
</body>
</html>
